#!/usr/bin/env perl

# Search CPAN by any part of the 01modules.index lines and sort by date

# Examples:
# perl parse-cpan MP3             # Include MP3
# perl parse-cpan MP3 Tag,Utils   # Exclude lines with either Tag OR Utils
# perl parse-cpan MP3 Tag,Utils 1 # Exclude lines with both Tag AND Utils
# perl parse-cpan 'MP\d'          # MP3 and MP4 modules (regular expression search)
# perl parse-cpan GENE            # GENE's modules
# perl parse-cpan 1998            # Modules that haven't been updated since 1998
# perl parse-cpan ' 4k'           # Size = 4k modules
# perl parse-cpan '\d+M '         # Modules with a size in megabyes
# perl parse-cpan ' App-'         # Modules that begin with App::*

# * Remember: The include/exclude options regard raw 01modules.index lines.
# * Fancy regular expressions, like negative lookbehinds don't work. YMMV

use strict;
use warnings;

use HTTP::Simple;
use List::Util qw/all any/;
use Mojo::DOM;
use Time::Piece;

my $include = shift || 'Math';
my $exclude = shift || '';
my $and     = shift || 0; # Use AND logic to determine search matches

$include = [ split /,/, $include ];
$exclude = [ split /,/, $exclude ];

# Process long named modules into a "|" regular expression
my @modules;
for my $module (readline(DATA)) {
    chomp $module;
    push @modules, $module;
}
my $modules = join '|', @modules;
$modules = qr/(?:$modules|\w+)/;

my $url = 'https://www.cpan.org/modules/01modules.index.html';
print "Fetching $url...\n";
my $content = get $url;

my $dom = Mojo::DOM->new($content);
my @lines = split /\n/, $dom->at('pre')->all_text;

my @matches;

for my $line (@lines) {
    if ($and) {
        next unless all { $line =~ /$_/ } @$include;
        next if @$exclude && all { $line =~ /$_/ } @$exclude;
    }
    else {
        next unless any { $line =~ /$_/ } @$include;
        next if any { $line =~ /$_/ } @$exclude;
    }

    #                      module,      author,    dist,   size,        date
    my @parts = $line =~ /^($modules)\s*([A-Z]+)\s+(\S+)\s+([\d.]+\w)\s+(.*?)\s*\+?\s*$/;
    next unless $parts[0];

    my $t = Time::Piece->strptime($parts[4], '%d %b %Y');
    my $date = $t->strftime('%Y%m%d');

    push @matches, [@parts, $date];
}

my $width = length scalar @matches;

my %seen;
my $file = 'module.html';

my $i = 0;

for my $match (sort { $a->[5] cmp $b->[5] || $a->[2] cmp $b->[2] } @matches) {
    next if $seen{$match->[2]}++;

    $i++;

    my ($module, $version) = to_module($match->[2]);

    my $url = "https://metacpan.org/pod/$module";

    if ($module && $version && is_success(getstore($url, $file))) {
        printf "%*d. %s %s (%s) on %s by %s\n",
            $width, $i,
            $url, $version,
            @{$match}[3,4,1];
    }
    else {
        printf "%*d. %s\n",
            $width, $i,
            join(', ', @{$match}[2,3,4,1]);
    }
}

unlink $file;

sub to_module {
    my ($dist) = @_;
    my ($module, $version);
    if ($dist =~ /^(.*?)-([abv\d.]+)\.(?:tar\.gz|tgz|zip)$/) {
        $module  = $1;
        $version = $2;
        $module =~ s/-/::/g;
    }
    return $module, $version;
}

# These modules have no space separating the module and the author name:
__DATA__
ActiveRecord
ConfigReader
DataWarehouse
FormValidator
GoogleIDToken
KeywordsSpider
MetasploitExpress
NexposeSimpleXML
ProjectBuilder
RandomJungle
ReleaseAction
