#!/usr/bin/env perl

# Search CPAN by any part of the 01modules.index lines and sort by date

# Examples:
# perl parse-cpan MP3             # Include MP3
# perl parse-cpan MP3 Tag,Utils   # Exclude lines with either Tag OR Utils
# perl parse-cpan MP3 Tag,Utils 1 # Exclude lines with both Tag AND Utils
# perl parse-cpan 'MP\d'          # All MP3 and MP4 modules (regular expression search)
# perl parse-cpan GENE            # All GENE's modules
# perl parse-cpan ' 4k'           # All the size = 4k modules
# perl parse-cpan '\d+M '         # All the modules with a size in megabyes

use strict;
use warnings;

use HTTP::Simple;
use List::Util qw/all any/;
use Mojo::DOM;
use Time::Piece;

my $include = shift || 'Math';
my $exclude = shift || '';
my $and     = shift || 0; # Use AND logic to determine search matches

$include = [ split /,/, $include ];
$exclude = [ split /,/, $exclude ];

# These modules have no space separating the module and the author name
my $modules = qr/(?:ActiveRecord|ConfigReader|DataWarehouse|FormValidator|GoogleIDToken|KeywordsSpider|MetasploitExpress|NexposeSimpleXML|ProjectBuilder|RandomJungle|ReleaseAction|\w+)/;

my $url = 'https://www.cpan.org/modules/01modules.index.html';
print "Fetching $url ...\n";
my $content = get $url;

my $dom = Mojo::DOM->new($content);
my @lines = split /\n/, $dom->at('pre')->all_text;

my @matches;

for my $line (@lines) {
    if ($and) {
        next unless all { $line =~ /$_/ } @$include;
        next if @$exclude && all { $line =~ /$_/ } @$exclude;
    }
    else {
        next unless any { $line =~ /$_/ } @$include;
        next if any { $line =~ /$_/ } @$exclude;
    }

    #                      module,      author,    dist,   size,        date
    my @parts = $line =~ /^($modules)\s*([A-Z]+)\s+(\S+)\s+([\d.]+\w)\s+(.*?)\s*\+?\s*$/;
    next unless $parts[0];

    my $t = Time::Piece->strptime($parts[4], '%d %b %Y');
    my $date = $t->strftime('%Y%m%d');

    push @matches, [@parts, $date];
}

my $width = length scalar @matches;

my %seen;

my $i = 0;

for my $match (sort { $a->[5] cmp $b->[5] || $a->[2] cmp $b->[2] } @matches) {
    next if $seen{$match->[2]}++;

    $i++;

    my ($module, $version) = to_module($match->[2]);

    if ($module && $version) {
        printf "%*d. %s %s (%s) on %s by %s\n",
            $width, $i,
            $module, $version,
            @{$match}[3,4,1];
    }
    else {
        printf "%*d. %s\n",
            $width, $i,
            join(', ', @{$match}[2,3,4,1]);
    }
}

sub to_module {
    my ($dist) = @_;
    my ($module, $version);
    if ($dist =~ /^(.*?)-([abv\d.]+)\.(?:tar\.gz|tgz|zip)$/) {
        $module  = $1;
        $version = $2;
        $module =~ s/-/::/g;
    }
    return $module, $version;
}
