#!/usr/bin/env perl
#
# List or plot module dependencies
#
# Command line options are all Boolean except the path:
#   path : The path to the root of the search directory
#   core : Should we include core modules?
#   lc   : Should we include all-lowercase-named packages?
#   dump : Should we dump the dependencies as text?
#   img  : Should we generate a GraphViz image?
#
use strict;
use warnings;

use Capture::Tiny ':all';
use Data::Dumper::Concise;
use Devel::Dependencies;
use File::Find;
use GraphViz;
use Module::CoreList;

# Get the directory under which to look.
my $dir  = shift
    || die "Usage: perl $0 /fullpath/to/lib [core] [lc] [dump] [img]\n";
my $dump = shift || 0;  # Dump the modules & dependencies?
my $core = shift || 0;  # Include core modules?
my $lc   = shift || 0;  # Include all-lowercase packages?
my $img  = shift || 0;  # Generate an image?

# Internal variables:
my $node = {};  # Keep track of nodes for graphing.
my $deps = {};  # The bucket of module => [dependencies]
my $seen = {};  # Keep track of what has been seen.

# Locate all the dependencies below the given directory.
find(\&wanted, $dir);

# Show the results if requested.
print Dumper $deps if $dump;

# Graph the results if requested.
make_graphviz($node) if $img;

sub wanted { /\.pm$/ && deps($File::Find::name) }

sub deps { # Find the dependencies of the given module.
    # The module to investigate.
    my $module = shift || die "ERROR: No file provided.";
#warn "M:$module\n";

    # Find the file dependencies.
    my ($out, $err, $exit) = capture {
        system('perl', '-MDevel::Dependencies', $module);
    };
#warn "O:$out\n";
#warn "E:$err\n";
#warn "E:$exit\n";

    # Remove the path parts from the module.
    $module =~ s/^.*?\/lib\/(.*)$/$1/;

    # Routine to replace path/file with module::syntax in a package name.
    my $to_module = sub {
        my $package = shift;
        $package =~ s/\//::/g;
        $package =~ s/\.pm//;
        return $package;
    };

    # Replace file with module syntax.
    $module = $to_module->($module);

    # Remove the header.
    $out =~ s/Devel::Dependencies finds \d+ dependencies://;

    # Select all the dependencies individually.
    my @deps = split /\s+/, $out;
#warn "D:@deps\n";

    # Remove modules in core.
    for my $d (@deps) {
        next unless $d;

        # Replace file with module syntax.
        my $m = $to_module->($d);
#warn "M:$m\n";

        # Save or skip the module.
        if ($seen->{$m}     # Skip if seen
            || (!$core && Module::CoreList::is_core($m))  # Skip if core
            || (!$lc && $m !~ /[A-Z]/)  # Skip if lower-case
        ) {
            $seen->{$m}++;
        }
        else {
            # Add nodes unless already exist.
            $node->{$module}++ unless exists $node->{$module};
            $node->{$m}++ unless exists $node->{$m};

            # Save our dependency.
            push @{ $deps->{$module} }, $m;
#use Data::Dumper::Concise;warn Dumper$deps->{$module};
        }
    }
}

sub make_graphviz { # Generate the graph visualization.
    my $node = shift;

    # Make a graphviz instance.
    my $g = GraphViz->new(
        concentrate => 1,
        overlap => 'false',
    );

    # Consider the nodes of the field...
    for my $module (keys %$node) {
        # Add a vertex for this module & set the node value to it;
        $node->{$module} = $g->add_node($module);

        # Add edges for the dependencies.
        for my $dep (@{ $deps->{$module} }) {
            # Add a vertex for this dependent module unless seen.
            $node->{$dep} = $g->add_node($dep) unless ref $node->{$dep};

            # Add an edge for this dependency.
            $g->add_edge($node->{$module} => $node->{$dep});
        }
    }
    print $g->as_png( $0 . '.png' );
}
