#!/usr/bin/env perl
#
# List or plot module dependencies
# -- gene+github@ology.net
# Command line options are all Boolean except the path:
#   path : The path to the root of the search directory
#   core : Should we include core modules?
#   lc   : Should we include all-lowercase-named packages?
#   dump : Should we dump the dependencies as text?
#   img  : Should we generate a GraphViz image?
#
use strict;
use warnings;

use Capture::Tiny ':all';
use Data::Dumper;
# Devel::Dependencies is used, but in a command below.
use File::Find;
use GraphViz;
use Module::CoreList;

# Get the directory under which to look.
my $dir  = shift
    || die "Usage: perl $0 path/to/lib [core] [lc] [dump] [img]\n";
# Should we include core modules?
my $core = shift || 0;
# Should we include all-lowercase packages?
my $lc   = shift || 0;
# Should we dump the dependencies?
my $dump = shift || 0;
# Should we generate an image?
my $img  = shift || 0;

# Make a node table.
my $node = {};

# Recursively locate all the deps.
my $deps = {};  # The bucket of module => [dependencies]
my $seen = {};  # So we don't repeat ourselves.
find(\&wanted, $dir);

# Show the results.
if ($dump) {
    warn Data::Dumper->new([$deps])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
}

# Graph the results.
if ($img) {
    # Make a graphviz instance.
    my $g = GraphViz->new(
        concentrate => 1,
        overlap     => 'false',
    );

    # Consider the nodes of the field...
    for my $module (keys %$node) {
        # Add a vertex for this module.
        my $v = $g->add_node($module);

        # Reset the node module value to the graph vertex.
        $node->{$module} = $v;

        # Add edges for the dependencies.
        for my $dep (@{ $deps->{$module} }) {
            # Add a vertex for this dependent module unless seen.
            $node->{$dep} = $g->add_node($dep) unless ref $node->{$dep};

            # Add an edge for this dependency.
            $g->add_edge($node->{$module} => $node->{$dep});
        }
    }
    print $g->as_png;
}

sub wanted { /\.pm$/ && deps($File::Find::name) }

sub deps {
    # The module to investigate.
    my $module = shift || die "ERROR: No file provided.";

    # Find the file dependencies.
    my ($out, $err, $exit) = capture {
        system('perl', '-MDevel::Dependencies', $module);
    };

    # Remove the path parts from the module.
    $module =~ s/^.*?\/lib\/(.*)$/$1/;

    # Routine to replace path/file with module::syntax in a package name.
    my $to_module = sub {
        my $package = shift;
        $package =~ s/\//::/g;
        $package =~ s/\.pm//;
        return $package;
    };

    # Replace file with module syntax.
    $module = $to_module->($module);

    # Remove the header.
    $out =~ s/Devel::Dependencies finds \d+ dependencies://;

    # Select all the dependencies individually.
    my @deps = split /\s+/, $out;

    # Remove modules in core.
    for my $d (@deps) {
        # Replace file with module syntax.
        my $m = $to_module->($d);

        # Save or skip the module.
        if ($seen->{$m}     # Skip if seen
            || (!$core && Module::CoreList::is_core($m))  # Skip if core
            || (!$lc && $m !~ /[A-Z]/)  # Skip if lower-case
        ) {
            $seen->{$m}++;
        }
        else {
            # Add nodes unless already exist.
            $node->{$module}++ unless exists $node->{$module};
            $node->{$m}++ unless exists $node->{$m};

            # Save our dependency.
            push @{ $deps->{$module} }, $m;
        }
    }
}

